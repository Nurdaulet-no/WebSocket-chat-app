<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebSocket Chat Test - Full</title>
    <!-- Подключаем SockJS и StompJS -->
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7/bundles/stomp.umd.min.js"></script>
    <style>
        /* --- Базовые Стили --- */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; display: flex; height: 100vh; margin: 0; font-size: 14px; background-color: #f4f7f6; }
        #sidebar { width: 320px; border-right: 1px solid #d1d9d6; padding: 10px; display: flex; flex-direction: column; background-color: #ffffff; box-shadow: 1px 0 3px rgba(0,0,0,0.05); overflow-y: auto; } /* Added overflow-y */
        #chat-area { flex-grow: 1; display: flex; flex-direction: column; background-color: #e5ddd5; /* WhatsApp like background */ }
        .section { margin-bottom: 15px; padding: 12px; border: 1px solid #e0e0e0; background-color: #fff; border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .section h2 { font-size: 1.1em; font-weight: 600; margin-bottom: 10px; color: #333; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        label { display: block; margin-bottom: 4px; font-weight: 500; font-size: 0.85em; color: #555;}
        input[type=text], input[type=number], input[type=password] { width: 95%; padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9em; }
        button { padding: 8px 15px; margin-right: 5px; cursor: pointer; border: none; border-radius: 4px; background-color: #007bff; color: white; font-size: 0.9em; transition: background-color 0.2s ease; }
        button:hover:not(:disabled) { background-color: #0056b3; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; color: #666; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover:not(:disabled) { background-color: #5a6268; }
        button.danger { background-color: #dc3545; }
        button.danger:hover:not(:disabled) { background-color: #c82333; }
        #chat-list { max-height: 250px; overflow-y: auto; border: 1px solid #eee; margin-top: 10px; padding: 0;} /* Adjusted height */
        .chat-item { padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; }
        .chat-item:last-child { border-bottom: none; }
        .chat-item:hover { background-color: #f0f8ff; }
        .chat-item.selected { background-color: #e0f0ff; font-weight: 600; }
        .chat-item-name { flex-grow: 1; }
        .chat-item-type { font-size: 0.8em; color: #888; margin-left: 10px; background-color: #eee; padding: 2px 5px; border-radius: 3px;}
        #messages { flex-grow: 1; overflow-y: auto; padding: 15px; border-bottom: 1px solid #ccc; background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAYAAAA8AXHiAAABU0lEQVR4nO3SQQ3AIADDsJT/fy1NSIkq3QGcM2fefAvA6OEDAwPDHAYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGBgYGGZjYGBgmI2BgcFhBgYGBobZGNi7AWwXQA5N698gAAAAAElFTkSuQmCC"); /* Subtle background pattern */ }
        .message { display: flex; flex-direction: column; margin-bottom: 10px; max-width: 75%; padding: 8px 12px; border-radius: 8px; word-wrap: break-word; box-shadow: 0 1px 1px rgba(0,0,0,0.1); }
        .message .sender { font-weight: 600; margin-bottom: 3px; font-size: 0.85em; color: #333;}
        .message .content { font-size: 0.95em; margin-bottom: 4px;}
        .message .time { font-size: 0.75em; color: #777; text-align: right; }
        .received { background-color: #ffffff; margin-right: auto; border: 1px solid #eee;}
        .sent { background-color: #dcf8c6; margin-left: auto; border: 1px solid #c5e8a6;} /* WhatsApp sent bubble style */
        .sent .sender { color: #005045; }
        .sent .time { color: #5f8b5b; }
        .system-message { font-style: italic; color: #888; text-align: center; margin: 10px 0; font-size: 0.85em; background-color: #f0f0f0; padding: 5px; border-radius: 5px;} /* Style for system messages */
        #message-input-area { padding: 10px 15px; display: flex; background-color: #f0f0f0; border-top: 1px solid #ddd;}
        #messageInput { flex-grow: 1; margin-right: 10px; padding: 10px; border-radius: 20px; border: 1px solid #ccc; }
        #sendBtn { border-radius: 50%; width: 40px; height: 40px; padding: 0; display: flex; align-items: center; justify-content: center;}
        #status { font-size: 0.85em; color: #555; margin-top: 8px; border-top: 1px dashed #ccc; padding-top: 8px;}
        #chat-title { padding: 12px 15px; border-bottom: 1px solid #ccc; background-color: #ededed; font-weight: 600; text-align: center; font-size: 1.05em;}
        .error { color: #dc3545; font-weight: bold; }
        .info { color: #007bff; }
        .success { color: #28a745; }
        /* --- NEW STYLES for Participant Management --- */
        #participant-management { display: none; /* Hide by default */ }
        #participant-management.visible { display: block; }
        #participant-list { font-size: 0.9em; max-height: 100px; overflow-y: auto; margin-top: 5px; border: 1px solid #eee; padding: 5px; background-color: #fdfdfd;}
        #participant-list span { display: block; padding: 3px 5px; border-bottom: 1px dotted #eee; }
        #participant-list span:last-child { border-bottom: none; }
        /* --- End New Styles --- */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
    </style>
</head>
<body>
<div id="sidebar">
    <!-- Connection Section -->
    <div class="section">
        <h2>Connection</h2>
        <div> <label for="token">JWT Token:</label> <input type="password" id="token" placeholder="Paste your JWT here"> </div>
        <div> <button id="connectBtn" onclick="connect()">Connect</button> <button id="disconnectBtn" onclick="disconnect()" disabled class="secondary">Disconnect</button> </div>
        <div id="status">Status: Disconnected</div>
    </div>

    <!-- Create Chat Section -->
    <div class="section">
        <h2>Create Chat</h2>
        <div> <label for="groupName">Group Name:</label> <input type="text" id="groupName" placeholder="Enter name for new group"> <button id="createGroupBtn" onclick="createGroupChat()" disabled>Create Group</button> <small style="font-size: 0.8em; color: #666;">Creates group with only you.</small> </div>
        <hr style="margin: 10px 0;">
        <div> <label for="privateChatUsername">Username for Private Chat:</label> <input type="text" id="privateChatUsername" placeholder="Enter Username"> <button id="createPrivateChatBtn" onclick="getOrCreatePrivateChat()" disabled>Get/Create Private</button> </div>
    </div>

    <!-- *** NEW: Participant Management Section *** -->
    <div id="participant-management" class="section">
        <h2>Manage Participants (<span id="pm-group-name">Group</span>)</h2>
        <div> <label for="participantUsername">Username:</label> <input type="text" id="participantUsername" placeholder="Username to add/remove"> </div>
        <div>
            <button id="addParticipantBtn" onclick="addParticipant()" disabled>Add</button>
            <button id="removeParticipantBtn" onclick="removeParticipant()" disabled class="danger">Remove</button>
        </div>
        <div style="margin-top: 10px;">
            <strong>Current Participants:</strong>
            <div id="participant-list"></div>
        </div>
    </div>
    <!-- *** END NEW Section *** -->


    <!-- Chat List Section -->
    <div class="section" style="flex-grow: 1; display: flex; flex-direction: column;">
        <h2>Your Chats</h2>
        <button id="refreshChatsBtn" onclick="loadUserChats()" disabled class="secondary" style="margin-bottom: 5px;">Refresh List</button>
        <div id="chat-list"> <p style="color: #888; padding: 10px;">Connect to load chats...</p> </div>
    </div>
</div>

<!-- Main Chat Area -->
<div id="chat-area">
    <div id="chat-title">No chat selected</div>
    <div id="messages"></div>
    <div id="message-input-area">
        <input type="text" id="messageInput" placeholder="Type message..." disabled>
        <button id="sendBtn" onclick="sendMessage()" disabled title="Send">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-send-fill" viewBox="0 0 16 16"> <path d="M15.964.686a.5.5 0 0 0-.65-.65L.767 5.855H.766l-.452.18a.5.5 0 0 0-.082.887l.41.26.001.002 4.995 3.178 3.178 4.995.002.002.26.41a.5.5 0 0 0 .886-.083l6-15Zm-1.833 1.89L6.637 10.07l-.215-.338a.5.5 0 0 0-.154-.154l-.338-.215 7.494-7.494 1.178-.471Z"/> </svg>
        </button>
    </div>
</div>

<script>
    // Global State
    let stompClient = null;
    let currentUser = null; // { username: string, token: string }
    let currentChat = null; // { id: number, name: string, type: string, participants: string[] } // Added participants
    let currentSubscription = null;
    const API_BASE_URL = 'http://localhost:8080/api';

    // DOM Elements (cached)
    const tokenInput = document.getElementById('token');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const groupNameInput = document.getElementById('groupName');
    const createGroupBtn = document.getElementById('createGroupBtn');
    const privateChatUsernameInput = document.getElementById('privateChatUsername');
    const createPrivateChatBtn = document.getElementById('createPrivateChatBtn');
    const chatListDiv = document.getElementById('chat-list');
    const refreshChatsBtn = document.getElementById('refreshChatsBtn');
    const chatTitle = document.getElementById('chat-title');
    const messagesDiv = document.getElementById('messages');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const statusDiv = document.getElementById('status');
    // New Participant Management Elements
    const pmSection = document.getElementById('participant-management');
    const pmGroupNameSpan = document.getElementById('pm-group-name');
    const participantUsernameInput = document.getElementById('participantUsername');
    const addParticipantBtn = document.getElementById('addParticipantBtn');
    const removeParticipantBtn = document.getElementById('removeParticipantBtn');
    const participantListDiv = document.getElementById('participant-list');

    // --- Logging ---
    function log(message, type = 'info') {
        console.log(`[${type.toUpperCase()}] ${message}`); // Log to browser console as well
        const msgElement = document.createElement('div');
        msgElement.className = `system-message ${type}`; // Use classes for styling flexibility
        const textNode = document.createTextNode(`[${new Date().toLocaleTimeString()}] ${message}`);
        msgElement.appendChild(textNode);
        messagesDiv.appendChild(msgElement);
        scrollToBottom();
    }
    function logError(message, error) {
        console.error(`[ERROR] ${message}`, error);
        const msgElement = document.createElement('div');
        msgElement.classList.add('system-message', 'error'); // Use system-message for styling
        msgElement.textContent = `[${new Date().toLocaleTimeString()}] ERROR: ${message}`;
        if (error && error.message) {
            const details = document.createElement('span');
            details.style.fontSize = '0.8em';
            details.textContent = ` (${error.message})`;
            msgElement.appendChild(details);
        } else if (error && typeof error === 'object') {
            // Attempt to stringify simple objects, avoid complex ones
            try {
                const errorStr = JSON.stringify(error, null, 2); // Pretty print
                if(errorStr.length < 300) { // Avoid huge logs
                    const details = document.createElement('pre');
                    details.style.fontSize = '0.8em';
                    details.style.whiteSpace = 'pre-wrap'; // Wrap long lines
                    details.textContent = errorStr;
                    msgElement.appendChild(details);
                }
            } catch(e) { /* Ignore stringify errors */ }
        }
        messagesDiv.appendChild(msgElement);
        scrollToBottom();
    }

    // --- UI State ---
    function setUIState(connected) {
        tokenInput.disabled = connected;
        connectBtn.disabled = connected;
        disconnectBtn.disabled = !connected;
        createGroupBtn.disabled = !connected;
        createPrivateChatBtn.disabled = !connected;
        refreshChatsBtn.disabled = !connected;
        groupNameInput.disabled = !connected;
        privateChatUsernameInput.disabled = !connected;

        const chatSelected = connected && currentChat;
        messageInput.disabled = !chatSelected;
        sendBtn.disabled = !chatSelected;

        // --- Participant Management UI Logic ---
        const groupChatSelected = chatSelected && currentChat.type === 'GROUP';
        if (groupChatSelected) {
            pmSection.style.display = 'block'; // Show PM section
            pmGroupNameSpan.textContent = currentChat.name || `Group ${currentChat.id}`; // Update title
            addParticipantBtn.disabled = false;
            removeParticipantBtn.disabled = false;
            participantUsernameInput.disabled = false;
        } else {
            pmSection.style.display = 'none'; // Hide PM section
            addParticipantBtn.disabled = true;
            removeParticipantBtn.disabled = true;
            participantUsernameInput.disabled = true;
            participantUsernameInput.value = ''; // Clear input if not group
            participantListDiv.innerHTML = ''; // Clear participant list
        }
        // --- End Participant Management UI ---

        if (connected) {
            statusDiv.textContent = `Status: Connected as ${currentUser.username}`;
            chatTitle.textContent = currentChat ? `${currentChat.name} (ID: ${currentChat.id}, Type: ${currentChat.type})` : 'Select a chat';
            if(currentChat) messageInput.focus();
        } else {
            statusDiv.textContent = 'Status: Disconnected';
            chatTitle.textContent = 'No chat selected';
            chatListDiv.innerHTML = '<p style="color: #888; padding: 10px;">Connect to load chats...</p>';
            messagesDiv.innerHTML = '';
            // pmSection is hidden by the logic above
            currentChat = null;
            currentUser = null;
            currentSubscription = null;
        }
    }

    // --- JWT Decoding ---
    function decodeJwtPayload(token) {
        try {
            const base64Url = token.split('.')[1];
            if (!base64Url) throw new Error("Invalid JWT structure");
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
            return JSON.parse(jsonPayload);
        } catch (e) {
            console.error('Could not decode JWT payload', e);
            logError('Invalid JWT token format.'); // Log error to UI
            return null;
        }
    }

    // --- API Calls ---
    async function apiFetch(url, options = {}) {
        if (!currentUser || !currentUser.token) {
            logError("Authentication token is missing.");
            throw new Error("Not authenticated.");
        }
        const defaultHeaders = {
            'Authorization': `Bearer ${currentUser.token}`,
            'Content-Type': 'application/json'
        };
        const config = {
            ...options,
            headers: {
                ...defaultHeaders,
                ...options.headers,
            },
        };
        try {
            const response = await fetch(API_BASE_URL + url, config);
            if (!response.ok) {
                let errorData;
                try { errorData = await response.json(); } catch (e) { errorData = await response.text(); }
                logError(`API Error ${response.status}: ${response.statusText}`, { url, responseData: errorData });
                throw new Error(`API Error: ${response.status}`);
            }
            if (response.status === 204 || response.headers.get("content-length") === "0") { return null; }
            const data = await response.json();
            return data;
        } catch(error) {
            logError(`Network or parsing error during API fetch to ${url}`, error);
            throw error; // Re-throw after logging
        }
    }

    // --- WebSocket Logic ---
    function connect() {
        const jwtToken = tokenInput.value.trim();
        if (!jwtToken) { logError("JWT Token is required!"); return; }
        const payload = decodeJwtPayload(jwtToken);
        if (!payload || !payload.sub) { return; } // Error logged in decode function

        currentUser = { username: payload.sub, token: jwtToken };
        log(`Attempting to connect as ${currentUser.username}...`);

        const socketFactory = () => new SockJS('http://localhost:8080/ws');
        stompClient = new StompJs.Client({
            webSocketFactory: socketFactory,
            connectHeaders: { Authorization: `Bearer ${currentUser.token}` },
            reconnectDelay: 10000,
            // debug: (str) => { if(!str.includes('PING') && !str.includes('PONG')) console.log('STOMP:', str); } // Optional Debug
        });

        stompClient.onConnect = async (frame) => {
            setUIState(true);
            log('Successfully connected to STOMP broker', 'success');
            await loadUserChats();
        };
        stompClient.onStompError = (frame) => { logError(`Broker error: ${frame.headers['message']}. Details: ${frame.body}`); handleDisconnect(false); };
        stompClient.onWebSocketError = (event) => { logError('WebSocket connection error', event); handleDisconnect(true); };
        stompClient.onWebSocketClose = (event) => { log(`WebSocket closed: Code=${event.code}, Reason=${event.reason || 'N/A'}`, 'warn'); handleDisconnect(false); };

        try { stompClient.activate(); } catch (error) { logError('STOMP client activation error', error); handleDisconnect(true); }
    }

    function subscribeToRoom(roomId) {
        if (!stompClient || !stompClient.connected) { logError("Cannot subscribe, client not connected."); return; }
        unsubscribeCurrent();

        const topic = `/topic/chats/${roomId}`;
        log(`Subscribing to ${topic}...`);
        try {
            currentSubscription = stompClient.subscribe(topic, (message) => {
                try {
                    const payload = JSON.parse(message.body);
                    console.log("Received WS payload:", payload); // Keep for debug

                    // --- Logic based on `payload.sender` ---
                    if (payload.sender && payload.sender === "System") {
                        log(`System message: ${payload.content}`); // Log system message to UI
                        if (currentChat && currentChat.id === roomId) {
                            displaySystemMessage(payload.content); // Display in chat area
                            // Check if system message implies participant change
                            const lowerContent = payload.content.toLowerCase();
                            if (lowerContent.includes('joined') || lowerContent.includes('left') || lowerContent.includes('added') || lowerContent.includes('removed')) {
                                log("Participant change detected, refreshing chat list...");
                                loadUserChats(); // Refresh list to get updated participant counts/lists
                                // Optionally, if the current chat is the one affected, fetch its details again
                                if (currentChat && currentChat.id === roomId && currentChat.type === 'GROUP') {
                                    fetchChatDetails(roomId); // Fetch updated participant list specifically
                                }
                            }
                        }
                    } else if (payload.sender && payload.sender !== currentUser.username) {
                        // Message from another user
                        if (currentChat && currentChat.id === roomId) {
                            displayChatMessage(payload.sender, payload.content, payload.createdAt || new Date().toISOString()); // Display message
                        } else {
                            log(`Message for inactive chat ${roomId} from ${payload.sender}.`);
                            const chatItem = document.getElementById(`chat-${roomId}`);
                            if (chatItem) { // Highlight inactive chat
                                chatItem.style.fontWeight = 'bold';
                                chatItem.style.backgroundColor = '#fffacd';
                            }
                        }
                    } else if (payload.sender && payload.sender === currentUser.username) {
                        // Own message echoed back - ignore, already displayed optimistically
                    } else {
                        logError("Received message with unexpected/missing 'sender'", payload);
                    }
                } catch (e) {
                    logError("Error parsing or processing WS message: " + message.body, e);
                }
            }, { id: `sub-room-${roomId}` });
            log(`Subscribed successfully to ${topic}`, 'success');
        } catch (error) {
            logError(`Failed to subscribe to ${topic}`, error);
        }
    }


    function unsubscribeCurrent() {
        if (currentSubscription) {
            try {
                const subId = currentSubscription.id;
                currentSubscription.unsubscribe();
                log(`Unsubscribed from ${subId || 'previous topic'}`);
            } catch (e) { logError("Error unsubscribing", e); }
            currentSubscription = null;
        }
    }

    function handleDisconnect(logMsg = true) {
        unsubscribeCurrent(); // Ensure unsubscribed
        if (stompClient && stompClient.active) {
            try { stompClient.deactivate(); } catch (e) { logError("Error during STOMP deactivation", e); }
        }
        stompClient = null; // Clear client object
        setUIState(false); // Reset UI and state variables (currentUser, currentChat)
        if (logMsg) log("Connection closed or failed.", 'warn');
    }

    function disconnect() { log("Disconnecting..."); handleDisconnect(true); }

    // --- Chat Functionality ---
    async function loadUserChats() {
        if (!currentUser) return;
        log("Loading user chats...");
        refreshChatsBtn.disabled = true;
        try {
            const chats = await apiFetch('/chats'); // Expects list of ChatRoomDto
            displayChatList(chats);
            log(`Loaded ${chats.length} chats.`, 'success');
        } catch (error) { chatListDiv.innerHTML = '<p class="error">Failed to load chats. Check console.</p>'; }
        finally { refreshChatsBtn.disabled = !currentUser; }
    }

    function displayChatList(chats) {
        chatListDiv.innerHTML = '';
        if (!chats || chats.length === 0) { chatListDiv.innerHTML = '<p style="color: #888; padding:10px;">No chats found.</p>'; return; }

        chats.sort((a, b) => { // Sort groups first, then by name
            if (a.type === 'GROUP' && b.type !== 'GROUP') return -1;
            if (a.type !== 'GROUP' && b.type === 'GROUP') return 1;
            const nameA = a.name || `Chat ${a.id}`;
            const nameB = b.name || `Chat ${b.id}`;
            return nameA.localeCompare(nameB);
        });

        chats.forEach(chat => {
            const chatDiv = document.createElement('div');
            chatDiv.id = `chat-${chat.id}`;
            chatDiv.className = 'chat-item';
            let displayName = chat.name;
            // Use participantUsernames from DTO if available
            let participantUsernames = chat.participantUsernames || [];

            if (chat.type === 'PRIVATE') {
                // Find the other user's name for display
                displayName = participantUsernames.find(u => u !== currentUser.username) || 'Private Chat';
            } else if (!displayName && chat.type === 'GROUP') {
                displayName = `Group ${chat.id}`; // Fallback name
            }

            chatDiv.dataset.chatId = chat.id;
            chatDiv.dataset.chatName = displayName;
            chatDiv.dataset.chatType = chat.type;

            const nameSpan = document.createElement('span');
            nameSpan.className = 'chat-item-name';
            nameSpan.textContent = displayName;

            const typeSpan = document.createElement('span');
            typeSpan.className = 'chat-item-type';
            typeSpan.textContent = chat.type;
            if (chat.type === 'GROUP') { // Add participant count for groups
                typeSpan.textContent += ` (${participantUsernames.length})`;
            }

            chatDiv.appendChild(nameSpan);
            chatDiv.appendChild(typeSpan);

            if (currentChat && currentChat.id === chat.id) { chatDiv.classList.add('selected'); }

            // Pass participant usernames when selecting the chat
            chatDiv.onclick = () => selectChat(chat.id, displayName, chat.type, participantUsernames);
            chatListDiv.appendChild(chatDiv);
        });
    }

    async function selectChat(id, name, type, participants = []) { // Accept participants
        if (currentChat && currentChat.id === id) {
            // Optional: If clicking the same chat, refresh its details
            if (type === 'GROUP') {
                fetchChatDetails(id); // Re-fetch details including participants
            }
            return;
        }

        if (currentChat) { // Deselect previous
            const prevItem = document.getElementById(`chat-${currentChat.id}`);
            if (prevItem) prevItem.classList.remove('selected');
        }
        const currentItem = document.getElementById(`chat-${id}`); // Select new
        if (currentItem) {
            currentItem.classList.add('selected');
            currentItem.style.fontWeight = 'normal'; // Clear any notification highlights
            currentItem.style.backgroundColor = '';
        }

        // Store complete chat info including participants
        currentChat = { id, name, type, participants };
        log(`Selected chat: ${name} (ID: ${id}, Type: ${type})`);
        setUIState(true); // Update UI state (enables PM section if group)
        updateParticipantList(participants); // Display the initial participants list

        messagesDiv.innerHTML = ''; // Clear previous messages
        subscribeToRoom(id);
        await loadChatHistory(id);
    }

    // New function to fetch detailed chat info (specifically for participants)
    async function fetchChatDetails(chatId) {
        if (!currentUser || currentChat?.id !== chatId || currentChat?.type !== 'GROUP') return; // Only for current group chat
        log(`Fetching details for chat ${chatId}...`);
        try {
            const chatDto = await apiFetch(`/chats/${chatId}`); // Assuming endpoint GET /api/chats/{id} exists
            if (chatDto && chatDto.participantUsernames) {
                currentChat.participants = chatDto.participantUsernames; // Update state
                currentChat.name = chatDto.name; // Update name if it changed
                updateParticipantList(currentChat.participants); // Update UI
                // Update chat list item display (count, name)
                const chatItem = document.getElementById(`chat-${chatId}`);
                if (chatItem) {
                    const nameSpan = chatItem.querySelector('.chat-item-name');
                    const typeSpan = chatItem.querySelector('.chat-item-type');
                    if(nameSpan) nameSpan.textContent = currentChat.name;
                    if (typeSpan) typeSpan.textContent = `${currentChat.type} (${currentChat.participants.length})`;
                }
                log(`Chat ${chatId} details updated.`, 'success');
            }
        } catch (error) {
            logError(`Failed to fetch details for chat ${chatId}`, error);
        }
    }


    async function loadChatHistory(roomId) {
        if (!currentUser) return;
        log(`Loading history for room ${roomId}...`);
        messagesDiv.innerHTML = '<p class="info system-message">Loading messages...</p>';
        try {
            const page = await apiFetch(`/chats/${roomId}/messages?page=0&size=50&sort=createdAt,asc`);
            messagesDiv.innerHTML = ''; // Clear placeholder
            if (page && page.content && page.content.length > 0) {
                page.content.forEach(msg => displayChatMessage(msg.sender, msg.content, msg.createdAt)); // USE SENDER
                log(`Loaded ${page.content.length} messages for room ${roomId}.`);
                setTimeout(scrollToBottom, 100); // Scroll after rendering
            } else {
                messagesDiv.innerHTML = '<p style="color: #888; text-align: center; margin-top: 20px;" class="system-message">No messages in this chat yet.</p>';
            }
        } catch (error) { messagesDiv.innerHTML = '<p class="error system-message">Failed to load messages.</p>'; }
    }

    function displayChatMessage(sender, content, timestamp) {
        if (!currentUser) { console.warn("currentUser not set, cannot display message"); return; } // Safety check

        const messageDiv = document.createElement('div');
        messageDiv.className = 'message ' + (sender === currentUser.username ? 'sent' : 'received'); // Compare with currentUser.username

        const senderSpan = document.createElement('span');
        senderSpan.className = 'sender';
        senderSpan.textContent = sender; // Show sender's name

        const contentNode = document.createElement('div'); // Use div for content
        contentNode.className = 'content';
        contentNode.textContent = content; // Safely set text

        const timeSpan = document.createElement('span');
        timeSpan.className = 'time';
        timeSpan.textContent = timestamp ? new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : ''; // Format time

        messageDiv.appendChild(senderSpan);
        messageDiv.appendChild(contentNode);
        messageDiv.appendChild(timeSpan);
        messagesDiv.appendChild(messageDiv);

        // Scroll logic
        const isScrolledToBottom = messagesDiv.scrollHeight - messagesDiv.clientHeight <= messagesDiv.scrollTop + 80; // Increased buffer
        if (isScrolledToBottom || sender === currentUser.username) {
            scrollToBottom();
        }
    }

    function displaySystemMessage(content) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'system-message';
        messageDiv.textContent = `--- ${content} ---`; // Simple display
        messagesDiv.appendChild(messageDiv);
        scrollToBottom();
    }

    function sendMessage() {
        const messageContent = messageInput.value.trim();
        if (!currentChat) { logError("Cannot send, no chat selected!"); return; }
        if (!messageContent) { return; } // Don't send empty
        if (!currentUser) { logError("Cannot send, currentUser not set!"); return; } // Safety check

        if (stompClient && stompClient.connected) {
            const chatMessage = { content: messageContent }; // Backend expects only content
            const destination = `/app/chat/${currentChat.id}/sendMessage`;
            try {
                // Optimistic UI update
                displayChatMessage(currentUser.username, messageContent, new Date().toISOString()); // Use ISO string for consistency

                stompClient.publish({ destination: destination, body: JSON.stringify(chatMessage) });
                messageInput.value = ''; // Clear input
            } catch (error) {
                logError(`Failed to send message to ${destination}`, error);
                // Optional: Remove the optimistically added message on failure
            }
        } else {
            logError('Cannot send message: STOMP client not connected.');
        }
    }


    // --- Chat Creation ---
    async function createGroupChat() {
        const groupName = groupNameInput.value.trim();
        if (!groupName) { logError("Group name cannot be empty!"); return; }
        if (!currentUser) { logError("Connect first!"); return; }
        log(`Attempting to create group: ${groupName}`);
        createGroupBtn.disabled = true;
        try {
            const requestBody = { groupName: groupName }; // Only name needed
            const newChat = await apiFetch('/chats/group', { method: 'POST', body: JSON.stringify(requestBody) });
            log(`Group chat created: ${JSON.stringify(newChat)}`, 'success');
            groupNameInput.value = '';
            await loadUserChats(); // Refresh list
            // Auto-select the new chat
            selectChat(newChat.id, newChat.name, newChat.type, newChat.participantUsernames);
        } catch (error) { alert('Error creating group. Check console.'); }
        finally { createGroupBtn.disabled = !currentUser; }
    }

    async function getOrCreatePrivateChat() {
        const username = privateChatUsernameInput.value.trim();
        if (!username) { logError("Username for private chat cannot be empty!"); return; }
        if (!currentUser) { logError("Connect first!"); return; }
        if (username === currentUser.username) { logError("Cannot create a private chat with yourself!"); alert("Cannot create a private chat with yourself."); return; }

        log(`Attempting to get/create private chat with user: ${username}`);
        createPrivateChatBtn.disabled = true;
        try {
            const newChat = await apiFetch(`/chats/private/${username}`, { method: 'POST' });
            log(`Private chat obtained/created: ${JSON.stringify(newChat)}`, 'success');
            privateChatUsernameInput.value = '';
            await loadUserChats();
            // Auto-select the new/existing chat
            selectChat(newChat.id, newChat.name, newChat.type, newChat.participantUsernames);
        } catch (error) { alert('Error getting/creating private chat. Check console.'); }
        finally { createPrivateChatBtn.disabled = !currentUser; }
    }

    // --- *** NEW: Participant Management Functions *** ---
    function updateParticipantList(participants = []) { // Default to empty array
        if (!currentChat || currentChat.type !== 'GROUP') {
            participantListDiv.innerHTML = ''; // Clear if not relevant
            // pmSection is handled by setUIState
            return;
        }

        participantListDiv.innerHTML = ''; // Clear previous list

        // Ensure participants is an array
        const participantArray = Array.isArray(participants) ? participants : [];

        if(participantArray.length === 0) {
            participantListDiv.innerHTML = '<span>No participants found (or list empty).</span>';
            return;
        }

        participantArray.sort(); // Sort alphabetically
        participantArray.forEach(username => {
            const pDiv = document.createElement('span');
            pDiv.textContent = username;
            // Add a delete button next to each participant (except self)
            if (username !== currentUser.username) {
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'x';
                removeBtn.title = `Remove ${username}`;
                removeBtn.className = 'danger';
                removeBtn.style.marginLeft = '10px';
                removeBtn.style.padding = '1px 5px';
                removeBtn.style.fontSize = '0.8em';
                removeBtn.style.lineHeight = '1'; // Adjust line height
                removeBtn.onclick = (e) => {
                    e.stopPropagation(); // Prevent chat selection if clicking button
                    if (confirm(`Are you sure you want to remove ${username}?`)) {
                        participantUsernameInput.value = username; // Pre-fill input for clarity
                        removeParticipant();
                    }
                };
                pDiv.appendChild(removeBtn);
            } else {
                pDiv.textContent += " (You)"; // Indicate self
            }
            participantListDiv.appendChild(pDiv);
        });
    }

    async function addParticipant() {
        const usernameToAdd = participantUsernameInput.value.trim();
        if (!usernameToAdd) { logError("Enter username to add!"); return; }
        if (!currentChat || currentChat.type !== 'GROUP') { logError("Select a group chat first!"); return; }

        log(`Attempting to add ${usernameToAdd} to group ${currentChat.id}`);
        addParticipantBtn.disabled = true;
        removeParticipantBtn.disabled = true;

        try {
            // API: PUT /api/chats/{chatId}/participants/{username}
            // Expects updated ChatRoomDto in response
            const updatedChatDto = await apiFetch(`/chats/${currentChat.id}/participants/${usernameToAdd}`, {
                method: 'PUT'
            });

            log(`${usernameToAdd} added successfully!`, 'success');
            participantUsernameInput.value = ''; // Clear input

            // Update state and UI from the response DTO
            if (updatedChatDto && updatedChatDto.participantUsernames) {
                currentChat.participants = updatedChatDto.participantUsernames;
                updateParticipantList(currentChat.participants); // Refresh list display
                // Update the count in the main chat list
                const chatItem = document.getElementById(`chat-${currentChat.id}`);
                if (chatItem) {
                    const typeSpan = chatItem.querySelector('.chat-item-type');
                    if (typeSpan) typeSpan.textContent = `${currentChat.type} (${currentChat.participants.length})`;
                }
            } else {
                // If DTO didn't come back as expected, fetch details again
                await fetchChatDetails(currentChat.id);
            }

        } catch (error) {
            logError(`Failed to add ${usernameToAdd}`, error);
            alert(`Failed to add participant. Check console/logs.`);
        } finally {
            // Re-enable buttons based on current state
            const groupChatSelected = currentChat && currentChat.type === 'GROUP';
            addParticipantBtn.disabled = !groupChatSelected;
            removeParticipantBtn.disabled = !groupChatSelected;
        }
    }

    async function removeParticipant() {
        const usernameToRemove = participantUsernameInput.value.trim();
        if (!usernameToRemove) { logError("Enter username to remove!"); return; }
        if (!currentChat || currentChat.type !== 'GROUP') { logError("Select a group chat first!"); return; }
        if (usernameToRemove === currentUser.username) { logError("Cannot remove yourself this way."); alert("Cannot remove yourself."); return; }

        log(`Attempting to remove ${usernameToRemove} from group ${currentChat.id}`);
        addParticipantBtn.disabled = true;
        removeParticipantBtn.disabled = true;

        try {
            // API: DELETE /api/chats/{chatId}/participants/{username}
            // Expects 204 No Content on success
            await apiFetch(`/chats/${currentChat.id}/participants/${usernameToRemove}`, {
                method: 'DELETE'
            });

            log(`${usernameToRemove} removed successfully!`, 'success');
            participantUsernameInput.value = ''; // Clear input

            // Manually update the participant list in the state
            if (currentChat.participants) {
                currentChat.participants = currentChat.participants.filter(p => p !== usernameToRemove);
                updateParticipantList(currentChat.participants); // Refresh the UI list
                // Update the count in the main chat list
                const chatItem = document.getElementById(`chat-${currentChat.id}`);
                if (chatItem) {
                    const typeSpan = chatItem.querySelector('.chat-item-type');
                    if (typeSpan) typeSpan.textContent = `${currentChat.type} (${currentChat.participants.length})`;
                }
            } else {
                // Fallback if state was somehow missing participants
                await fetchChatDetails(currentChat.id);
            }

        } catch (error) {
            logError(`Failed to remove ${usernameToRemove}`, error);
            alert(`Failed to remove participant. Check console/logs.`);
        } finally {
            const groupChatSelected = currentChat && currentChat.type === 'GROUP';
            addParticipantBtn.disabled = !groupChatSelected;
            removeParticipantBtn.disabled = !groupChatSelected;
        }
    }


    // --- Initialization ---
    setUIState(false); // Initial UI state

    // --- Event Listeners ---
    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !sendBtn.disabled) { sendMessage(); }
    });
    // Optional: Add keypress listener for participant input
    participantUsernameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !addParticipantBtn.disabled) { addParticipant(); }
    });

    // --- Helper to scroll messages ---
    function scrollToBottom() {
        setTimeout(() => { if(messagesDiv) messagesDiv.scrollTop = messagesDiv.scrollHeight; }, 50);
    }

</script>
</body>
</html>